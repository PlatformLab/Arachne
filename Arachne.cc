/* Copyright (c) 2015-2016 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdio.h>
#include <string.h>
#include <thread>
#include "PerfUtils/TimeTrace.h"
#include "PerfUtils/Util.h"

#include "Arachne.h"
#include "Semaphore.h"

namespace Arachne {

// Change 0 -> 1 in the following line to compile detailed time tracing in
// this file.
#define TIME_TRACE 0

using PerfUtils::Cycles;
using PerfUtils::TimeTrace;

/**
  * This variable prevents multiple initializations of the library, but does
  * not protect against the user calling Arachne functions without initializing
  * the library, which results in undefined behavior.
  */
bool initialized = false;

// Used to allow redirection of error messages generated by the library.
FILE* errorStream = stderr;

std::function<void()> initCore = nullptr;

// The following configuration options can be passed into init.

/**
  * The minimum number of cores this application needs to run. This number must
  * be at least one higher than the number of cores which are permanently
  * exclusive.
  *
  * If this is set higher than the number of physical cores, the kernel will
  * multiplex, which is usually undesirable except when running unit tests on a
  * single-core system.
  */
volatile uint32_t minNumCores;

/**
  * This tracks the actual number of unblocked cores in the system.
  */
std::atomic<uint32_t> numActiveCores;

/**
  * The largest number of cores that Arachne is permitted to utilize.
  * It is an invariant that maxNumCores >= numActiveCores, but if the user explicitly
  * sets both then numActiveCores will push maxNumCores up to satisfy the invariant.
  */
volatile uint32_t maxNumCores;

/**
  * Protect state related to changes in the number of cores, and prevents
  * multiple threads from simultaneously attempting to change the number of
  * cores.
  */
SpinLock coreChangeMutex(false);

/**
  * The mutex above cannot be held across the scaling up and down of the number
  * of cores, so this variable is set when there is a core change in effect, to
  * prevent multiple core changes from occurring simultaneously.
  */
volatile bool coreChangeActive;

/**
  * Used to ensure that only one thread attempts to become exclusive or shared
  * at a time. This protects against a thread being migrated while it is
  * halfway through makeExclusiveOnCore and making incorrect assumptiosn about
  * the core it is currently on.
  */
SleepLock coreExclusionMutex;

/**
  * Configurable maximum stack size for all threads.
  */
int stackSize = 1024 * 1024;

/**
  * Keep track of the kernel threads we are running so that we can join them on
  * destruction. Also, store a pointer to the original stacks to facilitate
  * switching back and joining.
  */
std::vector<std::thread> kernelThreads;
std::vector<void*> kernelThreadStacks;

/**
  * Alert the kernel threads that they should exit immediately. This is used
  * only for testing.
  */
volatile bool shutdown;

/**
  * Alert the kernel thread that cleanup is complete and it should block for
  * ramp-down.
  */
thread_local bool threadShouldYield;

/**
  * The collection of possibly runnable contexts for each kernel thread.
  */
std::vector<ThreadContext**> allThreadContexts;

/**
  * This pointer allows fast access to the current kernel thread's
  * localThreadContexts without computing an offset from the global
  * allThreadContexts vector on each access.
  */
thread_local ThreadContext** localThreadContexts;

/**
  * Holds the identifier for the thread in which it is stored: allows each
  * kernel thread to identify itself. This should eventually become a coreId,
  * when we support multiple kernel threads per core to handle blocking system
  * calls.
  */
thread_local int kernelThreadId;

/**
  * This is the context that a given kernel thread is currently executing.
  */
thread_local ThreadContext *loadedContext;

/**
  * See documentation for MaskAndCount.
  */
std::vector<std::atomic<MaskAndCount> * > occupiedAndCount;
thread_local std::atomic<MaskAndCount> *localOccupiedAndCount;

/**
  * This table maps a contiguous range of virtual core ID's to indices into an
  * immutable table pairing each ThreadContext** with its corresponding
  * MaskAndCount structure.
  */
int* virtualCoreTable;

/**
  * Setting a jth bit in the ith element of this vector indicates that the
  * priority of the thread living at index j on core i is temporarily raised.
  */
std::vector< std::atomic<uint64_t> *> publicPriorityMasks;

/**
  * This represents each core's local copy of the high-priority mask. Each call
  * to dispatch() will first examine this bitmask. It will clear the first set
  * bit and switch to that context. If there are no set bits, it will copy the
  * current value of publicPriorityMasks for the current core to here, and then
  * atomically clear those bits using an atomic OR.
  *
  * When ramping down cores, this value (if nonzero) should be cleared, since
  * all non-terminated threads on this core will be migrated away from this
  * thread.
  */
thread_local uint64_t privatePriorityMask;

/**
  * This variable holds the index into the current kernel thread's
  * localThreadContexts that it will check first the next time it looks for a
  * thread to run. It is used to implement round-robin scheduling of Arachne
  * threads.
  */
thread_local size_t nextCandidateIndex = 0;

/**
  * If we ran this many threads or more in one pass over the core array, then
  * we will attempt to increase the number of cores.
  */
uint64_t CORE_INCREASE_THRESHOLD = 5;

/**
  * If we ran this many threads or more in one pass over the core array, then
  * we will attempt to decrease the number of cores.
  */
uint64_t CORE_DECREASE_THRESHOLD = 3;

void incrementCoreCount();
void decrementCoreCount();

/**
  * Kernel threads which are not actively polling block on this semaphore.
  */
Semaphore inactiveCores;

// BEGIN Testing-Specific Flags
bool disableLoadEstimation;
// END   Testing-Specific Flags

/**
  * Allocate a block of memory aligned at the beginning of a cache line.
  *
  * \param size
  *     The amount of memory to allocate.
  */
void*
cacheAlignAlloc(size_t size) {
    void *temp;
    int result = posix_memalign(&temp, CACHE_LINE_SIZE, size);
    if (result != 0) {
        fprintf(errorStream, "posix_memalign returned %s", strerror(result));
        exit(1);
    }
    assert((reinterpret_cast<uint64_t>(temp) & (CACHE_LINE_SIZE - 1)) == 0);
    return temp;
}

/**
 * Main function for a kernel thread, which roughly corresponds to a core in the
 * current design of the system.
 *
 * \param kId
 *     The kernel thread ID for the newly created kernel thread.
 */
void
threadMain() {
    PerfUtils::Util::pinAvailableCore();
    if (initCore) initCore();

    for(;;) {
        inactiveCores.wait();
        // Prevent the use of abandoned ThreadContext which occurred as a
        // result of a shutdown request.
        if (shutdown) break;
        kernelThreadId = virtualCoreTable[numActiveCores++];
        {
            std::lock_guard<SpinLock> _(coreChangeMutex);
            coreChangeActive = false;
        }

        localOccupiedAndCount = occupiedAndCount[kernelThreadId];
        localThreadContexts = allThreadContexts[kernelThreadId];

        // Clean up state from the previous thread that was using this data
        // structure.
        *localOccupiedAndCount = {0,0};

		// Correct the ThreadContext.coreId() here to match the existing core.
        for (uint8_t k = 0; k < maxThreadsPerCore; k++) {
			localThreadContexts[k]->coreId = static_cast<uint8_t>(kernelThreadId);
        }

        loadedContext = localThreadContexts[0];

        // Transfers control to the Arachne dispatcher.
        // This context has been pre-initialized by init so it will "return"
        // to the schedulerMainLoop.
        // This call will return iff shutDown is called from the main thread.
        swapcontext(&loadedContext->sp, &kernelThreadStacks[kernelThreadId]);
        numActiveCores--;
        if (shutdown) break;
        {
            std::lock_guard<SpinLock> _(coreChangeMutex);
            coreChangeActive = false;
        }
    }
}

/**
  * Save the current register values onto one stack and load fresh register
  * values from another stack.
  * This method does not return to its caller immediately. It returns to the
  * caller when another thread on the same kernel thread invokes this method
  * with the current value of target as the saved parameter.
  *
  * \param saved
  *     Address of the stack location to load register values from.
  * \param target
  *     Address of the stack location to save register values to.
  */
void __attribute__((noinline))
swapcontext(void **saved, void **target) {
    // This code depends on knowledge of the compiler's calling convention: rdi
    // and rsi are the first two arguments.
    // Alternative approaches tend to run into conflicts with compiler register
    // use.

    // Save the registers that the compiler expects to persist across method
    // calls and store the stack pointer's location after saving these
    // registers.
    // NB: The space used by the pushed and
    // popped registers must equal the value of SpaceForSavedRegisters, which
    // should be updated atomically with this assembly.
    asm("pushq %r12\n\t"
        "pushq %r13\n\t"
        "pushq %r14\n\t"
        "pushq %r15\n\t"
        "pushq %rbx\n\t"
        "pushq %rbp\n\t"
        "movq %rsp, (%rsi)");

    // Load the stack pointer and restore the registers
    asm("movq (%rdi), %rsp\n\t"
        "popq %rbp\n\t"
        "popq %rbx\n\t"
        "popq %r15\n\t"
        "popq %r14\n\t"
        "popq %r13\n\t"
        "popq %r12");
}

/**
  * This is the top level method executed by each thread context. It is never
  * directly invoked. Instead, the thread's context is set up to "return" to
  * this method when we context switch to it the first time.
  */
void
schedulerMainLoop() {
    while (true) {
        // Check for whether this thread should exit, for the purposes of
        // ramping down.
        if (threadShouldYield) {
			// Switch back to our kernel-provided stack to block in the Core
			// Arbiter, since the next time this thread unblocks, it may not
			// live on the same core, and will use a different set of user
			// contexts.
            asm("nop");
            swapcontext(
                    &kernelThreadStacks[kernelThreadId],
                    &loadedContext->sp);
        }
        // No thread to execute yet. This call will not return until we have
        // been assigned a new Arachne thread.
        dispatch();
        reinterpret_cast<ThreadInvocationEnabler*>(
                &loadedContext->threadInvocation)->runThread();
        // The thread has exited.
        // Cancel any wakeups the thread may have scheduled for itself before
        // exiting.
        loadedContext->wakeupTimeInCycles = UNOCCUPIED;

        // Bump the generation number for the next newborn thread.
        loadedContext->generation++;
        {
            // Handle joins
            std::lock_guard<SpinLock> joinGuard(loadedContext->joinLock);
            loadedContext->joinCV.notifyAll();
        }

        // The code below clears the occupied flag for the current
        // ThreadContext.
        //
        // While this logically comes before dispatch(), it is here to prevent
        // it from racing against thread creations that come before the start
        // of the outer loop, since the occupied flags for such creations would
        // get wiped out by this code.
        bool success;
        do {
            MaskAndCount slotMap = *localOccupiedAndCount;
            MaskAndCount oldSlotMap = slotMap;

            slotMap.numOccupied--;

            slotMap.occupied &=
                ~(1L << loadedContext->idInCore) & 0x00FFFFFFFFFFFFFF;
            success = localOccupiedAndCount->compare_exchange_strong(
                    oldSlotMap,
                    slotMap);
        } while (!success);

        // Newborn threads should not have elevated priority, even if the
        // predecessors had leftover priority
        privatePriorityMask &= ~(1L << (loadedContext->idInCore));
        *publicPriorityMasks[kernelThreadId] &= ~(1L << (loadedContext->idInCore));
    }
}

/**
  * This method is used as part of cooperative multithreading to give other
  * Arachne threads on the same core a chance to run.
  * It will return when all other threads have had a chance to run.
  */
void
yield() {
    if (!loadedContext) return;
    if (localOccupiedAndCount->load().numOccupied == 1 &&
            !shutdown && !threadShouldYield) return;
    // This thread is still runnable since it is merely yielding.
    loadedContext->wakeupTimeInCycles = 0L;
    dispatch();
}

/**
  * Sleep for at least ns nanoseconds. The amount of additional delay may be
  * impacted by other threads' activities such as blocking and yielding.
  */
void
sleep(uint64_t ns) {
    loadedContext->wakeupTimeInCycles =
        Cycles::rdtsc() + Cycles::fromNanoseconds(ns);
    dispatch();
}

/**
  * Return a thread handle for the currently executing thread, identical to the
  * one returned by the createThread call that initially created this thread.
  *
  * When invoked from a non-Arachne thread, this function returns
  * Arachne::NullThread.
  */
ThreadId
getThreadId() {
    return loadedContext ? ThreadId(loadedContext, loadedContext->generation)
        : Arachne::NullThread;
}

thread_local uint8_t numThreadsRan = 0;
/**
  * Deschedule the current thread until its wakeup time is reached (which may
  * have already happened) and find another thread to run. All direct and
  * indirect callers of this function must ensure that spurious wakeups are
  * safe.
  */
void
dispatch() {
    // Check the stack canary on the current context.
    if (*reinterpret_cast<uint64_t*>(loadedContext->stack) != StackCanary) {
        fprintf(errorStream, "Stack overflow detected on %p. Aborting...\n",
                loadedContext);
        fflush(errorStream);
        abort();
    }
    uint64_t currentCycles = Cycles::rdtsc();
    uint64_t mask = localOccupiedAndCount->load().occupied;

    // Check for high priority threads.
    if (!privatePriorityMask) {
        // Copy & paste from the public list.
        privatePriorityMask = *publicPriorityMasks[kernelThreadId];
        if (privatePriorityMask)
            *publicPriorityMasks[kernelThreadId] &= ~privatePriorityMask;
    }

    if (privatePriorityMask) {
        // This position is one-indexed with zero meaning that no bits were
        // set.
        int firstSetBit = ffsll(privatePriorityMask);
        if (firstSetBit) {
            firstSetBit--;
            privatePriorityMask &= ~(1L << (firstSetBit));

            ThreadContext* targetContext = localThreadContexts[firstSetBit];

            // Verify wakeup and occupied.
            if (targetContext->wakeupTimeInCycles == 0 &&
                    ((mask >> firstSetBit) & 1)) {
                if (targetContext == loadedContext) {
                    loadedContext->wakeupTimeInCycles = BLOCKED;
                    return;
                }
                void** saved = &loadedContext->sp;
                loadedContext = targetContext;
                swapcontext(&loadedContext->sp, saved);
                volatile ThreadContext* volatile forceReload =
                    const_cast<volatile ThreadContext* volatile>(loadedContext);
                forceReload->wakeupTimeInCycles = BLOCKED;
                return;
            }
        }
    }
    // Find a thread to switch to
    size_t currentIndex = nextCandidateIndex;
    mask >>= currentIndex;

    // Count the iterations it took us to find a runnable thread.
    // Heuristically, if this number is very small, then we may want to ramp up
    // the number of cores.
    for (;;currentIndex++, mask >>= 1L) {
        if (mask == 0) {
            // We have reached the end of the threads, so we should go back to
            // the beginning.
            currentIndex = 0;
            mask = localOccupiedAndCount->load().occupied;
            currentCycles = Cycles::rdtsc();

            if (!disableLoadEstimation) {
                // Check the number of threads ran in the last iteration.
                if (numThreadsRan > CORE_INCREASE_THRESHOLD && !coreChangeActive)
                    incrementCoreCount();
                else if (numThreadsRan < CORE_DECREASE_THRESHOLD && !coreChangeActive)
                    decrementCoreCount();

                numThreadsRan = 0;
            }

            // Check for termination
            if (shutdown)
                swapcontext(
                        &kernelThreadStacks[kernelThreadId],
                        &loadedContext->sp);
        }
        // Optimize to eliminate unoccupied contexts
        if (!(mask & 1))
            continue;

        ThreadContext* currentContext = localThreadContexts[currentIndex];
        if (currentCycles >= currentContext->wakeupTimeInCycles) {
            nextCandidateIndex = currentIndex + 1;
            if (nextCandidateIndex == maxThreadsPerCore) nextCandidateIndex = 0;

            if (currentContext == loadedContext) {
                loadedContext->wakeupTimeInCycles = BLOCKED;
                numThreadsRan++;
                return;
            }
            void** saved = &loadedContext->sp;
            loadedContext = currentContext;
            swapcontext(&loadedContext->sp, saved);
            // After the old context is swapped out above, this line executes
            // in the new context.
            volatile ThreadContext* volatile forceReload =
                const_cast<volatile ThreadContext* volatile>(loadedContext);
            forceReload->wakeupTimeInCycles = BLOCKED;
            numThreadsRan++;
            return;
        }
    }
}

/**
  * Make the thread referred to by ThreadId runnable.
  * If one thread exits and another is created between the check and the setting
  * of the wakeup flag, this signal will result in a spurious wake-up.
  * If this method is invoked on a currently running thread, it will have the
  * effect of causing the thread to immediately unblock the next time it blocks.
  *
  * \param id
  *     The id of the thread to signal.
  */
void
signal(ThreadId id) {
    uint64_t oldWakeupTime = id.context->wakeupTimeInCycles;
    if (oldWakeupTime != UNOCCUPIED) {
        // We do the CAS in assembly because we do not want to pay for the
        // extra memory fences for ordinary stores that std::atomic adds.
        uint64_t newValue = 0L;
        __asm__ __volatile__("lock; cmpxchgq %0,%1" : "=r" (newValue), 
                "=m" (id.context->wakeupTimeInCycles),
                "=a" (oldWakeupTime) : "0" (newValue), "2" (oldWakeupTime));

        // Raise the priority of the newly awakened thread.
        if (id.context->coreId != static_cast<uint8_t>(~0))
            *publicPriorityMasks[id.context->coreId] |=
                (1L << id.context->idInCore);
    }
}

/**
  * Block the current thread until the thread identified by id finishes its
  * execution.
  *
  * \param id
  *     The id of the thread to join.
  */
void
join(ThreadId id) {
    std::unique_lock<SpinLock> joinGuard(id.context->joinLock);
    // Thread has already exited.
    if (id.generation != id.context->generation) return;
    id.context->joinCV.wait(joinGuard);
}

/**
  * This function must be called by the main application thread and will block
  * until Arachne is terminated via a call to shutDown().
  *
  * Upon termination, this function tears down all state created by init,
  * and restores the state of the system to the time before init is
  * called.
  */
void waitForTermination() {
    for (size_t i = 0; i < kernelThreads.size(); i++) {
        kernelThreads[i].join();
    }

    // We now assume that all threads are done executing.
    PerfUtils::Util::serialize();

    kernelThreads.clear();
    kernelThreadStacks.clear();


    for (size_t i = 0; i < maxNumCores; i++) {
        for (int k = 0; k < maxThreadsPerCore; k++) {
            free(allThreadContexts[i][k]->stack);
            allThreadContexts[i][k]->joinLock.~SpinLock();
            allThreadContexts[i][k]->joinCV.~ConditionVariable();
            free(allThreadContexts[i][k]);
        }
        delete[] allThreadContexts[i];
        free(occupiedAndCount[i]);
    }
    allThreadContexts.clear();
    occupiedAndCount.clear();

    delete[] virtualCoreTable;
    inactiveCores.reset();
    PerfUtils::Util::serialize();
    initialized = false;

}

/**
  * This function parses out the arguments intended for the thread library from
  * a command line, and adjusts the values of argc and argv to eliminate the
  * arguments that the thread library consumed.
  */
void
parseOptions(int* argcp, const char** argv) {
    if (argcp == NULL) return;

    int argc = *argcp;

    struct OptionSpecifier {
        // The string that the user uses after `--`.
        const char* optionName;
        // The id for the option that is returned when it is recognized.
        int id;
        // Does the option take an argument?
        bool takesArgument;
    } optionSpecifiers[] = {
        {"minNumCores", 'c', true},
        {"maxNumCores", 'm', true},
        {"stackSize", 's', true}
    };
    const int UNRECOGNIZED = ~0;

    int i = 1;
    while (i < argc) {
        if (argv[i][0] != '-' || argv[i][1] != '-') {
            i++;
            continue;
        }
        const char* optionName = argv[i] + 2;
        int optionId = UNRECOGNIZED;
        const char* optionArgument = NULL;

        for (size_t k = 0;
                k < sizeof(optionSpecifiers) / sizeof(OptionSpecifier); k++) {
            const char* candidateName = optionSpecifiers[k].optionName;
            bool needsArg = optionSpecifiers[k].takesArgument;
            if (strncmp(candidateName,
                        optionName, strlen(candidateName)) == 0) {
                if (needsArg) {
                    if (i + 1 >= argc) {
                        fprintf(errorStream,
                                "Missing argument to option %s!\n",
                                candidateName);
                        break;
                    }
                    optionArgument = argv[i+1];
                    optionId = optionSpecifiers[k].id;
                    argc -= 2;
                    memmove(argv + i, argv + i + 2, (argc - i) * sizeof(char*));
                } else {
                    optionId = optionSpecifiers[k].id;
                    argc -= 1;
                    memmove(argv + i, argv + i + 1, (argc - i) * sizeof(char*));
                }
                break;
            }
        }
        switch (optionId) {
            case 'c':
                minNumCores = atoi(optionArgument);
                break;
            case 'm':
                maxNumCores = atoi(optionArgument);
                break;
            case 's':
                stackSize = atoi(optionArgument);
                break;
            case UNRECOGNIZED:
                i++;
        }
    }
    *argcp = argc;
}

ThreadContext::ThreadContext(uint8_t coreId, uint8_t idInCore)
    : stack(malloc(stackSize))
    , sp(reinterpret_cast<char*>(stack) +
            stackSize - 2*sizeof(void*))
    , wakeupTimeInCycles(UNOCCUPIED)
    , generation(1)
    , joinLock()
    , joinCV()
    , coreId(coreId)
    , idInCore(idInCore)
{
    // Immediately before schedulerMainLoop gains control, we want the
    // stack to look like this, so that the swapcontext call will
    // transfer control to schedulerMainLoop.
    //           +-----------------------+
    //           |                       |
    //           +-----------------------+
    //           |     Return Address    |
    //           +-----------------------+
    //     sp->  |       Registers       |
    //           +-----------------------+
    //           |                       |
    //           |                       |
    //
    // Set up the stack so that the first time we switch context to
    // this thread, we enter schedulerMainLoop.
    *reinterpret_cast<void**>(sp) = reinterpret_cast<void*>(schedulerMainLoop);

    /**
     * Decrement the stack pointer by the amount of space needed to
     * store the registers in swapcontext.
     */
    sp = reinterpret_cast<char*>(sp) - SpaceForSavedRegisters;

    /**
     * Set the stack canary value to detect stack overflows.
     */
    *reinterpret_cast<uint64_t*>(stack) = StackCanary;
}

/**
 * This function sets up state needed by the thread library, and must be
 * invoked before any other function in the thread library is invoked. It is
 * undefined behavior to invoke other Arachne functions before this one.
 *
 * Arachne will take configuration options from the command line specified by
 * argc and argv, and then update the values of argv and argc to reflect the
 * remaining arguments.
 *
 * Here are the current available options.
 *
 *     --minNumCores
 *        The minimum number of cores the application should use. This number
 *        must be at least one higher than the number of cores which are
 *        permanently exclusive.
 *     --maxNumCores
 *        The largest number of core the appliation may use
 *     --stackSize
 *        The size of each user stack.
 *
 * \param argcp
 *    The pointer to argc, the number of arguments passed to the application.
 *    This pointer will be used to update argc after Arachne has consumed its
 *    arguments.
 * \param argv
 *    The pointer to the command line argument array, which will be modiifed to
 *    remove the options that Arachne recognizes.
 */
void
init(int* argcp, const char** argv) {
    if (initialized)
        return;
    initialized = true;
    parseOptions(argcp, argv);

    if (minNumCores == 0)
        minNumCores = 1;
    if (maxNumCores == 0)
        maxNumCores = std::thread::hardware_concurrency();
    maxNumCores = std::max(minNumCores, maxNumCores);
    for (uint32_t i = 0; i < minNumCores; i++)
        inactiveCores.notify();

    // We assume that maxNumCores will not be exceeded in the lifetime of this
    // application.
    virtualCoreTable = new int[maxNumCores];
    for (unsigned int i = 0; i < maxNumCores; i++) {
        occupiedAndCount.push_back(
                reinterpret_cast<std::atomic<Arachne::MaskAndCount>* >(
                    cacheAlignAlloc(sizeof(MaskAndCount))));
        memset(occupiedAndCount.back(), 0, sizeof(std::atomic<MaskAndCount>));
        publicPriorityMasks.push_back(
                reinterpret_cast< std::atomic<uint64_t>* >(
                    cacheAlignAlloc(sizeof(std::atomic<uint64_t>))));
        memset(publicPriorityMasks.back(), 0, sizeof(std::atomic<uint64_t>));
        // Here we will allocate all the thread contexts and stacks
        ThreadContext **contexts = new ThreadContext*[maxThreadsPerCore];
        for (uint8_t k = 0; k < maxThreadsPerCore; k++) {
            contexts[k] = reinterpret_cast<ThreadContext*>(
                    cacheAlignAlloc(sizeof(ThreadContext)));
            new (contexts[k]) ThreadContext(static_cast<uint8_t>(i), k);
        }
        allThreadContexts.push_back(contexts);
        virtualCoreTable[i] = i;
    }

    // Allocate space to store all the original kernel pointers
    kernelThreadStacks.resize(maxNumCores);
    shutdown = false;

    // Ensure that data structure and stack allocation completes before we
    // begin to use it in a new thread.
    PerfUtils::Util::serialize();

    // Note that the main thread is not part of the thread pool.
    for (unsigned int i = 0; i < maxNumCores; i++) {
        // These threads are started with threadMain instead of
        // schedulerMainLoop because we want schedulerMainLoop to run on a user
        // stack rather than a kernel-provided stack. This enables us to run
        // the first user thread without a context switch.
        kernelThreads.emplace_back(threadMain);
    }

    // Block until minNumCores is active, per the application's requirements.
    while (numActiveCores != minNumCores) usleep(1);
}

/**
  * This function should be invoked in unit test setup to make Arachne
  * functions callable from the unit test, which is not an Arachne thread.
  *
  * This function sets up just enough state to allow the current thread to
  * execute unit tests which call Arachne functions.
  * We assume that the unit tests are run from the main kernel thread which
  * will never swap out when running the dispatch() loop.
  */
void
testInit() {
    kernelThreadId = numActiveCores;
    localOccupiedAndCount =
        reinterpret_cast<std::atomic<Arachne::MaskAndCount>* >(
            cacheAlignAlloc(sizeof(MaskAndCount)));
    memset(localOccupiedAndCount, 0, sizeof(MaskAndCount));

    localThreadContexts = new ThreadContext*[maxThreadsPerCore];
    for (uint8_t k = 0; k < maxThreadsPerCore; k++) {
        // Technically, this allocates a bunch of user stacks which will never
        // be used, and it can be optimized out if it turns out to be too
        // expensive.
        localThreadContexts[k] = reinterpret_cast<ThreadContext*>(
                cacheAlignAlloc(sizeof(ThreadContext)));
        new (localThreadContexts[k]) ThreadContext(~0, k);
        localThreadContexts[k]->wakeupTimeInCycles = BLOCKED;
    }
    loadedContext = *localThreadContexts;
    *localOccupiedAndCount = {1, 1};
}

/**
  * This function should be invoked in unit test teardown to clean up the state
  * that makes Arachne functions callable from the unit test.
  */
void testDestroy() {
    free(localOccupiedAndCount);
    for (int k = 0; k < maxThreadsPerCore; k++) {
        free(localThreadContexts[k]->stack);
        localThreadContexts[k]->joinLock.~SpinLock();
        localThreadContexts[k]->joinCV.~ConditionVariable();

        free(localThreadContexts[k]);
    }
    delete[] localThreadContexts;
    loadedContext = NULL;
    *localOccupiedAndCount = {0, 0};
}

/**
  * This call will cause all Arachne threads to terminate, and cause
  * waitForTermination() to return.
  *
  * It is typically used only for an application's unit tests, where the global
  * teardown function in the unit test would call Arachne::shutDown() followed
  * immediately by Arachne::waitForTermination().
  *
  * This function can be called from any Arachne or non-Arachne thread.
  */
void
shutDown() {
    // Unblock all cores so they can shut down and be joined.
    for (uint32_t i = 0; i < maxNumCores - numActiveCores; i++)
        inactiveCores.notify();

    // Tell all the kernel threads to terminate at the first opportunity.
    shutdown = true;
}


/**
 * Attempt to acquire this resource and block if it is not available.
 */
void
SleepLock::lock() {
    std::unique_lock<SpinLock> guard(blockedThreadsLock);
    if (owner == NULL) {
        owner = loadedContext;
        return;
    }
    blockedThreads.push_back(getThreadId());
    guard.unlock();
    do {
        // Spurious wake-ups can happen due to signalers of past inhabitants of
        // this loadedContext.
        dispatch();
    } while(owner != loadedContext);
}

/** 
 * Attempt to acquire this resource once.
 * \return
 *    Whether or not the acquisition succeeded.
 */
bool
SleepLock::try_lock() {
    std::lock_guard<SpinLock> guard(blockedThreadsLock);
    if (owner == NULL) {
        owner = loadedContext;
        return true;
    }
    return false;
}

/** Release resource. */
void
SleepLock::unlock() {
    std::lock_guard<SpinLock> guard(blockedThreadsLock);
    if (blockedThreads.empty()) {
        owner = NULL;
        return;
    }
    owner = blockedThreads.front().context;
    signal(blockedThreads.front());
    blockedThreads.pop_front();
}

ConditionVariable::ConditionVariable()
    : blockedThreads() {}

ConditionVariable::~ConditionVariable() { }

/**
  * Awaken one of the threads waiting on this condition variable.
  * The caller must hold the mutex that waiting threads held when they called
  * wait().
  */
void
ConditionVariable::notifyOne() {
    if (blockedThreads.empty()) return;
    ThreadId awakenedThread = blockedThreads.front();
    blockedThreads.pop_front();
    signal(awakenedThread);
}

/**
  * Awaken all of the threads waiting on this condition variable.
  * The caller must hold the mutex that waiting threads held when they called
  * wait().
  */
void
ConditionVariable::notifyAll() {
    while (!blockedThreads.empty())
        notifyOne();
}

/**
  * Change the target of the error stream, allowing redirection to an
  * application's log.
  */
void setErrorStream(FILE* stream) {
    errorStream = stream;
}

/**
 * This function runs on a core immediately before it is deallocated, and is
 * responsible for waiting out and then migrating running threads other than
 * itself. By ensuring that the core is busy running this thread, we ensure
 * that all other threads' contexts on this core are saved.
 */
void releaseCore() {
    bool makeExclusiveOnCore();
    // Remove all other threads from this core.
    makeExclusiveOnCore();
    threadShouldYield = true;
}

/**
  * This function can be called from any thread to increase the number of cores
  * used by Arachne.
  */
void incrementCoreCount() {
    std::lock_guard<SpinLock> _(coreChangeMutex);
    if (coreChangeActive) return;
    coreChangeActive = true;
    if (numActiveCores < maxNumCores) {
        fprintf(errorStream, "Number of cores increasing from %u to %u\n",
                numActiveCores.load(), numActiveCores + 1);
        fflush(errorStream);
        inactiveCores.notify();
    }
}

/**
  * This function can be called from any thread to arrange to decrease the
  * number of cores used by Arachne. It returns a core is actually released.
  */
void decrementCoreCount() {
    std::lock_guard<SpinLock> _(coreChangeMutex);
    if (coreChangeActive) return;
    if (numActiveCores <= minNumCores) return;

    coreChangeActive = true;
    fprintf(errorStream, "Number of cores decreasing from %u to %u\n",
            numActiveCores.load(), numActiveCores - 1);
    fflush(errorStream);

    // Find a core to deschedule
    uint8_t minLoaded = occupiedAndCount[0]->load().numOccupied;
    int minIndex = 0;
    for (uint32_t i = 1; i < numActiveCores; i++)
        if (occupiedAndCount[i]->load().numOccupied < minLoaded) {
            minLoaded = occupiedAndCount[i]->load().numOccupied;
            minIndex = i;
        }

    // Give up if the minLoaded core is exclusive or full, since that implies
    // we are likely pre-empting must-have cores.
    if (minLoaded >= static_cast<uint8_t>(56)) {
        fprintf(errorStream, "Failed to find an unoccupied core, giving up!\n");
        fprintf(errorStream, "numActiveCores = %u, occupiedAndCount: \n", numActiveCores.load());
        for (uint32_t i = 0; i < numActiveCores; i++) {
            fprintf(errorStream, "occupied = %lu, numOccupied = %u\n",
                    occupiedAndCount[i]->load().occupied, occupiedAndCount[i]->load().numOccupied);
        }

        fflush(errorStream);
        return;
    }

    // Create a thread on the target core to handle the actual core release,
    // since we are currently borrowing an arbitrary context and should not
    // hold it for too long.
    // Separate variable to avoid ambiguity between two versions of
    // createThread.
    createThreadOnCore(minIndex, releaseCore);
}

/**
  * This function is invoked from an Arachne thread and does not return until
  * it is the only thread on the core. If it returns true, it is valid for this
  * thread to never yield, because no other threads will share its core.
  *
  * Note that if too many threads call this function, Arachne will not be able
  * to offer very much concurrency.
  *
  * NB: If a thread invokes this function, it must invoke makeSharedOnCore
  * before exiting. We require this because this call is expected to be used
  * infrequently, and it does not make sense to pay the performance penalty for
  * checking on every thread exit. A caveat of this requirement is that a
  * thread which never exits until program termination has no need to invoke
  * makeSharedOnCore.
  */
bool makeExclusiveOnCore() {
    std::lock_guard<SleepLock> _(coreExclusionMutex);
    // Already exclusive
    if (localOccupiedAndCount->load().numOccupied > maxThreadsPerCore) {
        // If we are not the exclusive thread, then an error has occurred.
        if (localOccupiedAndCount->load().occupied !=
                (1U << loadedContext->idInCore))
            return true;
    }

    // Block future creations on core
    MaskAndCount targetOccupiedAndCount;
    MaskAndCount blockedOccupiedAndCount;
    bool success = false;
    do {
        targetOccupiedAndCount = *localOccupiedAndCount;
        blockedOccupiedAndCount = targetOccupiedAndCount;
        blockedOccupiedAndCount.numOccupied = EXCLUSIVE;
        success = localOccupiedAndCount->compare_exchange_strong(
                targetOccupiedAndCount, blockedOccupiedAndCount);
    } while (!success);

    // Wait out creations that finished CASing before we blocked creations
    bool pendingCreation;
    do {
        pendingCreation = false;
        for (int i = 0; i < maxThreadsPerCore; i++) {
            // It is safe to use targetOccupiedAndCount here, because the
            // success of the CAS indicates that all subsequent attempts to CAS
            // should have failed.
            // There is no race with completions here because no other thread
            // can be running on this core since we are running.
            if (((targetOccupiedAndCount.occupied >> i) & 1) &&
                    localThreadContexts[i]->wakeupTimeInCycles == UNOCCUPIED) {
                pendingCreation = true;
                break;
            }
        }
    } while (pendingCreation);

    // Wait out thread completions
    // If this interval is discovered to be too long, we can take a sleep &
    // poll approach.
    sleep(COMPLETION_WAIT_TIME);

    // Remap this slot in virtualCoreTable to point at the highest number, to
    // make it easier to pawn off work.
    for (uint32_t i = 0; i < maxNumCores; i++)
        if (virtualCoreTable[i] == kernelThreadId) {
            virtualCoreTable[i] = virtualCoreTable[numActiveCores - 1];
            virtualCoreTable[numActiveCores - 1] = kernelThreadId;
            break;
        }

    // Migrate off all threads other than the current one.  Round robin among
    // cores because these are likely long-running threads.
    int nextMigrationTarget = 0;
    int coreId = virtualCoreTable[nextMigrationTarget];

    blockedOccupiedAndCount = *localOccupiedAndCount;
    for (uint8_t i = 0; i < maxThreadsPerCore; i++) {
        if (i == loadedContext->idInCore) continue;
        if ((blockedOccupiedAndCount.occupied >> i) & 1) {
            uint8_t index;
            do {
                // Each iteration through this loop makes one attempt to enqueue the
                // task to the specified core. Multiple iterations are required only if
                // there is contention for the core's state variables.
                MaskAndCount slotMap = *occupiedAndCount[coreId];
                MaskAndCount oldSlotMap = slotMap;

                // If this happens, we should not be ramping down, since at
                // least one core is fully loaded.
                if (slotMap.numOccupied >= maxThreadsPerCore) {
                    abort();
                    return false;
                }

                // Search for a non-occupied slot and attempt to reserve the slot
                index = 0;
                while ((slotMap.occupied & (1L << index)) && index < maxThreadsPerCore)
                    index++;

                slotMap.occupied =
                    (slotMap.occupied | (1L << index)) & 0x00FFFFFFFFFFFFFF;
                slotMap.numOccupied++;
                success = occupiedAndCount[coreId]->compare_exchange_strong(
                            oldSlotMap, slotMap);
                blockedOccupiedAndCount.occupied &= ~(1 << i) & 0x00FFFFFFFFFFFFFF;
            } while (!success);

            // At this point we've reserved a spot on the target, and now we swap.
            ThreadContext* originalContext =
                allThreadContexts[coreId][index];
            allThreadContexts[coreId][index] = localThreadContexts[i];
            localThreadContexts[i] = originalContext;

            // Update idInCore to a consistent value
            allThreadContexts[coreId][index]->idInCore = index;
            localThreadContexts[i]->idInCore = i;

            allThreadContexts[coreId][index]->coreId =
                static_cast<uint8_t>(coreId);
            localThreadContexts[i]->coreId =
                static_cast<uint8_t>(kernelThreadId);

            // The next victim core that we will pawn our work on.
            nextMigrationTarget = (nextMigrationTarget + 1) % (numActiveCores - 1);
            coreId = virtualCoreTable[nextMigrationTarget];
        }
    }

    // Sanity checking that we are the only thread left on this core.
    int count = 0;
    for (int i = 0; i < maxThreadsPerCore; i++)
        if (blockedOccupiedAndCount.occupied & (1L << i))
            count++;
    if (count != 1)
        abort();

    // Update localOccupiedAndCount to a consistent state before exiting. At
    // this point, creations should have already been blocked, and completions
    // cannot occur because we are running, so we can just directly assign.
    *localOccupiedAndCount = blockedOccupiedAndCount;

    return true;
}

/**
  * This function reverses the effect of makeExclusiveOnCore(), allowing other
  * threads to once again be scheduled onto the core hosting this thread.
  *
  * If makeExclusiveOnCore has never been invoked from the current thread, then
  * this function is a no-op.
  */
void makeSharedOnCore() {
    std::lock_guard<SleepLock> _(coreExclusionMutex);
    // If not exclusive, this is a no-op.
    if (localOccupiedAndCount->load().numOccupied < maxThreadsPerCore)
        return;
    // Assume already exclusive
    MaskAndCount original = *localOccupiedAndCount;
    MaskAndCount shared = original;
    shared.numOccupied = 1;
    bool success = localOccupiedAndCount->compare_exchange_strong(
            original, shared);
    if (!success) {
        // If this scenario happens, it means there is a bug since nobody
        // should be able to create threads on an exclusive core.
        fprintf(errorStream, "Error making core shared again! Aborting...");
        fflush(errorStream);
        abort();
    }
}

} // namespace Arachne
